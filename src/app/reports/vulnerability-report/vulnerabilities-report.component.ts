import {Component, ElementRef, HostListener, Input, OnInit, QueryList, ViewChild, ViewChildren} from '@angular/core';
import {compareByName} from "@app/shared/compare-utils";
import {DateIntervalFilterComponent} from "@app/reports/filters/date-interval-filter/date-interval-filter.component";
import {EntityTreeFilterComponent} from "@app/reports/filters/entity-tree-select/entity-tree-filter.component";
import {ScrollStateService} from "@app/shared/scroll-state.service";
import { Entity } from '@app/models';
import { ReportService } from '@app/services/report.service';


@Component({
    selector: 'app-vulnerability-report',
    templateUrl: './vulnerabilities-report.component.html',
    styleUrls: ['./vulnerabilities-report.component.scss']
})
export class VulnerabilitiesReportComponent implements OnInit {

    @Input()
    displayDataOnly: false;

    @ViewChild('reportPreview', {static: false}) reportPreview: ElementRef;

    previewStateOpen = false;
    reportDate = new Date();

    // date interval
    // @ts-ignore
    @ViewChild(DateIntervalFilterComponent) dateInterval;

    // entity tree
    // @ts-ignore
    @ViewChild(EntityTreeFilterComponent) entityTree;

    // fix filter
    fixFilter: any = 'ALL';
    severityFilter = 'ALL';
    vulnsFilter = '';


    // report data
    totals: {
        entities,
        projects,
        components,
        vulnerabilities,
        severities: {

        }
    };
    entities = [];
    columns = [
        { header: 'Vulnerability'},
        { header: 'Component'},
        { header: 'Group'},
        { header: 'Version'},
        { header: 'Cwe'},
        { header: 'Severity'},
        { header: 'CVSS2'},
        { header: 'CVSS3'}/*,
        { header: 'Fix Version'}*/
    ];



    constructor(
        private reportService: ReportService,
        private scrollDisableService: ScrollStateService
    ) {}

    ngOnInit() {
        this.readVulnerabilitiesData(this.severityFilter, this.vulnsFilter);
    }


    onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
    }

    readVulnerabilitiesData(severity, vulns) {
        this.reportService.getVulnerabilities2(severity, vulns).subscribe(data => {

            console.log(data);

            this.entities = data;

            this.totals = {entities: 0, projects: 0, components: 0, vulnerabilities: 0, severities: {}};

            let entities = [];

            for (const entity of this.entities) {
                // this.totals.entities += 1;

                entities.push(entity.entityId);

                this.totals.projects += 1;

                for (const vulnerability of entity.vulnerabilities) {
                    this.totals.vulnerabilities += 1;

                    if (this.totals.severities.hasOwnProperty(vulnerability.severity)) {
                        this.totals.severities[vulnerability.severity]++;
                    }
                    else {
                        this.totals.severities[vulnerability.severity] = 0;
                    }
                }

                /*for (const component of entity.entityComponents.edges.map(e => e.node)) {
                    this.totals.components += 1;
                    this.totals.vulnerabilities += component.entityComponentVulnerabilities.edges.length;
                    for (const vulnerability of component.entityComponentVulnerabilities.edges) {
                        if (this.totals.severities.hasOwnProperty(vulnerability.node.severity)) {
                            this.totals.severities[vulnerability.node.severity]++;
                        }
                        else {
                            this.totals.severities[vulnerability.node.severity] = 0;
                        }
                    }
                }*/
            }

            this.totals.entities = entities.filter(this.onlyUnique).length;



            /*this.entities = data.data.entities.edges.map((e) => e.node).sort(compareByName);

            this.totals = {entities: 0, components: 0, vulnerabilities: 0, severities: {}};

            for (const entity of this.entities) {
                this.totals.entities += 1;
                for (const component of entity.entityComponents.edges.map(e => e.node)) {
                    this.totals.components += 1;
                    this.totals.vulnerabilities += component.entityComponentVulnerabilities.edges.length;
                    for (const vulnerability of component.entityComponentVulnerabilities.edges) {
                        if (this.totals.severities.hasOwnProperty(vulnerability.node.severity)) {
                            this.totals.severities[vulnerability.node.severity]++;
                        }
                        else {
                            this.totals.severities[vulnerability.node.severity] = 0;
                        }
                    }
                }
            }*/

            /*
            // option to flattern array of vulnerabilities
            for (const entity of this.entities) {
                entity.vulnerabilities = [];
                for (const component of entity.entityComponents.edges.map(e => e.node)) {
                    if (component.entityComponentVulnerabilities.edges.length > 0) {
                        entity.vulnerabilities.push.apply(
                            entity.vulnerabilities,
                            component.entityComponentVulnerabilities.edges.map((e) => {
                                const node = e.node;
                                node.component = component;
                                return node;
                            })
                        );
                    }
                }
            }*/
        }, error => {
            console.error("VulnerabilityReportComponent", error);
        });
    }


    onDateChange(event) {
        // console.log(event);
    }

    onApplyFilter() {
        // todo: apply filter heres
        // console.log(this.entitiesSelected);
        // console.log(this.dateInterval.dateStart);
        // console.log(this.dateInterval.dateEnd);
        // console.log(this.entityTree.entitiesSelected);



        // console.log("apply filter =================================================================================================");
        // console.log(this.severityFilter);
        // console.log(this.vulnsFilter);

        this.readVulnerabilitiesData(this.severityFilter, this.vulnsFilter);
    }

    onClearFilter() {
        // this.dateInterval.dateStart = '';
        // this.dateInterval.dateEnd = '';
        // this.fixFilter = 'ALL';
        // this.entityTree.entitiesSelected = [];

        this.severityFilter = 'ALL';
        this.vulnsFilter = '';

        this.readVulnerabilitiesData(this.severityFilter, this.vulnsFilter);
    }

    openPreview() {
        this.previewStateOpen = true;
        this.scrollDisableService.disableWindowScroll();
    }

    closePreview() {
        this.previewStateOpen = false;
        this.scrollDisableService.enableWindowScroll();
    }

    @HostListener('window:keydown', ['$event'])
    KeyDown(event: KeyboardEvent) {
        if (!this.displayDataOnly && event.keyCode === 27) {
            this.closePreview();
            event.stopPropagation();
            event.preventDefault();
        }
    }
}
