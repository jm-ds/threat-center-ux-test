import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {ActivatedRoute, Router} from '@angular/router';
import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';
import {NgbModal, NgbTabChangeEvent} from '@ng-bootstrap/ng-bootstrap';
import {
  PatchedInfoSimplified,
  VulnerableReleaseResponse,
  VulnerableReleaseResponseMap
} from '@app/threat-center/shared/models/types';
import {CoreHelperService} from '@app/services/core/core-helper.service';
import {
  FixComponentDialogComponent
} from "@app/threat-center/dashboard/project/fix-component-dialog/fix-component-dialog.component";
import {JiraCredentials, Vulnerability} from '@app/models';
import {ProjectBreadcumsService} from '@app/services/core/project-breadcums.service';
import {LazyLoadEvent} from "primeng";
import {PerfectScrollbarComponent} from "ngx-perfect-scrollbar";
import {ProjectService} from '@app/services/project.service';
import {FixService} from '@app/services/fix.service';
import {VulnerableCodeMappingService} from '@app/services/vulncode-mapping.service';
import {StateService} from '@app/services/state.service';
import {AuthenticationService} from "@app/security/services";
import {OrgService} from "@app/services/org.service";
import {
  CreateJiraTicketComponent
} from "@app/threat-center/dashboard/project/create-jira-ticket/create-jira-ticket.component";

@Component({
  selector: 'vulnerability-detail',
  templateUrl: './vulnerability-detail.component.html',
  styles: []
})
export class VulnerabilityDetailComponent implements OnInit, OnDestroy {

  scanId;
  obsVulnerability: Observable<Vulnerability>;
  componentColumns = ['Name', 'Group', 'Version', 'Internal', 'Licenses', 'Vulnerabilities'];
  releaseCols = ['Name', 'Version'];

  newVersion: string;

  projectId = "";
  breadcumDetail: any = {};

  binaryData = new Map<string, VulnerableReleaseResponse>();

  patchInfos = new Map<string, PatchedInfoSimplified>();

  // For Jira integration
  jiraCredentials: JiraCredentials;
  vulnId: string;

  @ViewChild('perfectScrollBinaryRelease') perfectScrollBinaryRelease: PerfectScrollbarComponent;

  constructor(
      private orgService: OrgService,
      private authService: AuthenticationService,
      private projectService: ProjectService,
      public stateService: StateService,
      private route: ActivatedRoute,
      private router: Router,
      private fixService: FixService,
      private coreHelperService: CoreHelperService,
      private modalService: NgbModal,
      private vulnerableCodeMappingService: VulnerableCodeMappingService,
      private changeDetector: ChangeDetectorRef,
      private projectBreadcumsService: ProjectBreadcumsService) {
  }


  ngOnInit() {
    console.log("Loading VulnerabilityDetailComponent");
    let vulnerabilityId = this.route.snapshot.paramMap.get('vulnerabilityId');
    let orgId = this.authService.currentUser.organization.orgId;
    this.scanId = this.route.snapshot.paramMap.get('scanId');
    let scanId = this.route.snapshot.paramMap.get('scanId');
    this.projectId = this.route.snapshot.paramMap.get('projectId');
    this.obsVulnerability = this.projectService.getVulnerability(vulnerabilityId, orgId, scanId)
        .pipe(map(result => {
          let vulnerability = result.data.vulnerability;
          this.vulnId = vulnerability.vulnId; // It is necessary for jira ticket
          this.fillComponentsPatchesInfo(vulnerability);
          this.fillBinaryData(vulnerability);
          return vulnerability;
        }));
    this.initBreadcum();

    // Get the entity settings and check if there are any Jira settings
    this.orgService.getOrgSettings().subscribe(
        data => {
          if (data.data.orgSettings.jiraCredentials) {
            this.jiraCredentials = data.data.orgSettings.jiraCredentials;
          }
        },
        error => {
          console.error("orgService.getOrgSettings().subscribe", error);
        }
    );
  }


  getPatchedInfo(compId: string, nextPatchedVersion: boolean): string {
    let version = "not found";
    let patchedInfo = this.patchInfos.get(compId);
    if (!patchedInfo) {
      return version;
    } else {
      if (nextPatchedVersion) {
        return this.patchInfos.get(compId).nextPatchedVersion;
      } else {
        return this.patchInfos.get(compId).latestPatchedVersion;
      }
    }
  }


  ngOnDestroy(): void {
    if (!!this.projectBreadcumsService.getProjectBreadcum()) {
      this.projectBreadcumsService.settingProjectBreadcum("", "", "", false);
    }
  }

  onTabChange($event: NgbTabChangeEvent) {
    this.stateService.vulnerability_tabs_selectedTab = $event.nextId;
  }

  fixVersion(componentId: string, oldVersion: string) {
    const  modalRef = this.modalService.open(FixComponentDialogComponent, {
      keyboard: false,
    });
    modalRef.componentInstance.scanId = this.scanId;
    modalRef.componentInstance.newVersion = this.newVersion;
    modalRef.componentInstance.oldVersion = oldVersion;
    modalRef.componentInstance.componentId = componentId;
  }


  createJiraTicket() {
    const  modalRef = this.modalService.open(CreateJiraTicketComponent, {
      keyboard: false,
    });
    let vulnerabilityId = this.route.snapshot.paramMap.get('vulnerabilityId');
    let orgId = this.authService.currentUser.organization.orgId;

    modalRef.componentInstance.projectId = this.projectId;
    modalRef.componentInstance.scanId = this.scanId;
    modalRef.componentInstance.orgId = orgId;
    modalRef.componentInstance.vulnerabilityId = vulnerabilityId;
    modalRef.componentInstance.vulnId = this.vulnId;
  }

  gotoProject() {
    const entityId = this.route.snapshot.paramMap.get('entityId');
    const url = "dashboard/entity/" + entityId + "/project/" + this.projectId;
    this.router.navigate([url]);
  }

  gotoComponent() {
    const entityId = this.route.snapshot.paramMap.get('entityId');
    const url = "dashboard/entity/" + entityId + '/project/' + this.projectId + '/scan/' + this.scanId + "/component/" + this.breadcumDetail.SelectedComponent['id'];
    this.router.navigate([url]);
  }

  loadBinaryReleasesLazy(event: LazyLoadEvent, componentId: string) {
    let binaryVulnerableResponse = this.binaryData.get(componentId);
    if (binaryVulnerableResponse.nextPagingState != null) {
      this.vulnerableCodeMappingService.nextVulnerabilitiesWithCvssV3(
          binaryVulnerableResponse.nextPagingState, binaryVulnerableResponse.repositoryType, binaryVulnerableResponse.purlType, binaryVulnerableResponse.group, binaryVulnerableResponse.name)
          .subscribe((data: VulnerableReleaseResponse) => {
            binaryVulnerableResponse.vulnerableReleases.push(...data.vulnerableReleases);
            binaryVulnerableResponse.nextPagingState = data.nextPagingState;
            this.perfectScrollBinaryRelease.directiveRef.update();
            this.changeDetector.detectChanges();
          });
    }
  }

  private fillBinaryData(vulnerability: Vulnerability) {
    vulnerability.components.edges.forEach(comp => {
      this.vulnerableCodeMappingService.startVulnerabilitiesWithCvssV3(comp.node.componentId).subscribe((data: VulnerableReleaseResponseMap) => {
        this.binaryData.set(comp.node.componentId, data.binaryVulnerableResponse);
      });
    });
  }

  // Initialize breadcum details
  private initBreadcum() {
    this.breadcumDetail = this.projectBreadcumsService.getProjectBreadcum();
  }

  private fillComponentsPatchesInfo(vulnerability: Vulnerability) {
    // todo: ref: this is secuintal requests to get component patched version. Remaster it to request data with single graphql call when getting vulnerability.
    //  At backend we should update query chain to be able to select as follows: Vulnerability -> components -> patched versions
    vulnerability.components.edges.forEach(comp => {
      this.fixService.getPatchedVersion(comp.node.componentId).subscribe(res => {
        this.patchInfos.set(comp.node.componentId, res);
      });
    });
  }

  // Generating the correct URL for a jira ticket
  openJiraTicket(key: string, self: string) {
    let url: string;
    if (this.jiraCredentials) {
      url = this.jiraCredentials.projectUrl + '/browse/' + key;
    } else {
      let selfUrl = new URL(self);
      url = selfUrl.hostname + '/browse/' + key;
    }
    window.open(url, "_blank");
  }
}
