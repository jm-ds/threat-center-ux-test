import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {ActivatedRoute, Router} from '@angular/router';
import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';
import {NgbModal, NgbTabChangeEvent} from '@ng-bootstrap/ng-bootstrap';
import {
  PatchedInfo,
  VulnerableReleaseResponse,
  VulnerableReleaseResponseMap
} from '@app/threat-center/shared/models/types';
import { StateService} from '@app/threat-center/shared/services';
import {CoreHelperService} from '@app/core/services/core-helper.service';
import {FixService} from "@app/threat-center/dashboard/project/services/fix.service";
import {FixComponentDialogComponent} from "@app/threat-center/dashboard/project/fix-component-dialog/fix-component-dialog.component";
import {Vulnerability} from '@app/models';
import {ProjectBreadcumsService} from '@app/core/services/project-breadcums.service';
import {LazyLoadEvent} from "primeng";
import {VulnerableCodeMappingService} from "@app/threat-center/dashboard/project/services/vulncode-mapping.service";
import {PerfectScrollbarComponent} from "ngx-perfect-scrollbar";
import { ProjectService } from '@app/services/project.service';

@Component({
  selector: 'vulnerability-detail',
  templateUrl: './vulnerability-detail.component.html',
  styles: []
})
export class VulnerabilityDetailComponent implements OnInit, OnDestroy {

  scanId;
  obsVulnerability: Observable<Vulnerability>;
  componentColumns = ['Name', 'Group', 'Version', 'Internal', 'Licenses', 'Vulnerabilities'];
  releaseCols = ['Name', 'Version'];

  newVersion: string;

  projectId = "";
  breadcumDetail: any = {};

  binaryData = new Map<string, VulnerableReleaseResponse>();

  patchInfos = new Map<string, PatchedInfo>();

  @ViewChild('perfectScrollBinaryRelease', {static: false}) perfectScrollBinaryRelease: PerfectScrollbarComponent;

  constructor(
    private projectService:ProjectService,
    private stateService: StateService,
    private route: ActivatedRoute,
    private router: Router,
    private fixService: FixService,
    private coreHelperService: CoreHelperService,
    private modalService: NgbModal,
    private vulnerableCodeMappingService: VulnerableCodeMappingService,
    private changeDetector: ChangeDetectorRef,
    private projectBreadcumsService: ProjectBreadcumsService) { }


  ngOnInit() {
    console.log("Loading VulnerabilityDetailComponent");
    let vulnerabilityId = this.route.snapshot.paramMap.get('vulnerabilityId');
    this.projectId = this.route.snapshot.paramMap.get('projectId');
    console.log("vulnerabilityId:", vulnerabilityId);
    this.scanId = this.route.snapshot.paramMap.get('scanId');
    this.obsVulnerability = this.projectService.getVulnerability(vulnerabilityId)
        .pipe(map(result => {
          let vulnerability = result.data.vulnerability;
          this.fillComponentsPatchesInfo(vulnerability);
          this.fillBinaryData(vulnerability);
          return vulnerability;
        }));
    this.initBreadcum();
  }


  getPatchedInfo(compId: string, nextPatchedVersion: boolean): string {
    let version = "not found";
    let patchedInfo = this.patchInfos.get(compId);
    if (!patchedInfo) {
      return version;
    } else {
      if (nextPatchedVersion) {
        return this.patchInfos.get(compId).nextPatchedVersion.version;
      } else {
        return this.patchInfos.get(compId).latestPatchedVersion.version;
      }
    }
  }


  ngOnDestroy(): void {
    if (!!this.projectBreadcumsService.getProjectBreadcum()) {
      this.projectBreadcumsService.settingProjectBreadcum("", "", "", false);
    }
  }

  onTabChange($event: NgbTabChangeEvent) {
    this.stateService.vulnerability_tabs_selectedTab = $event.nextId;
  }

  fixVersion(componentId: string, oldVersion: string) {
    const  modalRef = this.modalService.open(FixComponentDialogComponent, {
      keyboard: false,
    });
    modalRef.componentInstance.scanId = this.scanId;
    modalRef.componentInstance.newVersion = this.newVersion;
    modalRef.componentInstance.oldVersion = oldVersion;
    modalRef.componentInstance.componentId = componentId;
  }

  gotoProject() {
    const entityId = this.route.snapshot.paramMap.get('entityId');
    const url = "dashboard/entity/" + entityId + "/project/" + this.projectId;
    this.router.navigate([url]);
  }

  gotoComponent() {
    const entityId = this.route.snapshot.paramMap.get('entityId');
    const url = "dashboard/entity/" + entityId + "/project/" + this.projectId + "/component/" + this.breadcumDetail.SelectedComponent['id'];
    this.router.navigate([url]);
  }

  loadBinaryReleasesLazy(event: LazyLoadEvent, componentId: string) {
    let binaryVulnerableResponse = this.binaryData.get(componentId);
    if (binaryVulnerableResponse.nextPagingState != null) {
      this.vulnerableCodeMappingService.nextVulnerabilitiesWithCvssV3(
          binaryVulnerableResponse.nextPagingState, binaryVulnerableResponse.repositoryType, binaryVulnerableResponse.purlType, binaryVulnerableResponse.group, binaryVulnerableResponse.name)
          .subscribe((data: VulnerableReleaseResponse) => {
            binaryVulnerableResponse.vulnerableReleases.push(...data.vulnerableReleases);
            binaryVulnerableResponse.nextPagingState = data.nextPagingState;
            this.perfectScrollBinaryRelease.directiveRef.update();
            this.changeDetector.detectChanges();
          });
    }
  }

  private fillBinaryData(vulnerability: Vulnerability) {
    vulnerability.components.edges.forEach(comp => {
      this.vulnerableCodeMappingService.startVulnerabilitiesWithCvssV3(comp.node.componentId).subscribe((data: VulnerableReleaseResponseMap) => {
        this.binaryData.set(comp.node.componentId, data.binaryVulnerableResponse);
      });
    });
  }

  // Initialize breadcum details
  private initBreadcum() {
    this.breadcumDetail = this.projectBreadcumsService.getProjectBreadcum();
  }

  private fillComponentsPatchesInfo(vulnerability: Vulnerability) {
    vulnerability.components.edges.forEach(comp => {
      this.fixService.getPatchedVersion(comp.node.componentId).subscribe(res => {
        this.patchInfos.set(comp.node.componentId, res);
      });
    });
  }
}
